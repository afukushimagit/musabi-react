const sketch = (p5obj:any) => {
/**    ランダムな点描によるデジタル時計  分や時が切り替わった後，徐々に描画が変化していく．    */  // 時間表示のスケール値[（スクリーンの）幅に対する率,高さに対する率] const DIGITS_SCALE: number[] = [  0.80, 0.60  ];  // 各桁間の間隔 一桁分の幅に対する率 const DIGIT_INTERVAL: number = 0.6; // コロンの幅 一桁分の幅に対する率 const COLON_WIDTH_RATE: number = 0.1;  // 桁番号 01:23 // 各桁の座標[桁番号][x,y] let fDigitPos: number[][] = new Array(4).fill([]).map(() => new Array(2));  // 各桁のサイズ[桁番号][w,h] let fDigitSize: number[][] = new Array(4).fill([]).map(() => new Array(2));  // コロンの挿入場所(桁番号に対応) const COLON_LOC_IDX: number = 2;  /** セグメント番号  4  -  0|5|2  -  1| |3  -  6  */ // セグメント範囲の左上座標 [セグメント番号][x,y] let fSegmentUpperLeft: number[][] = new Array(7).fill([]).map(() => new Array(2)); // セグメント範囲のサイズ [セグメント番号][w,h] let fSegmentSize: number[][] = new Array(7).fill([]).map(() => new Array(2)); // セグメント同士の重なり [0-1] let fSegmentsLap: number = 0.5; // セグメントの太さ [0-1] let fSegmentsThickness: number[] = [  0.2, 0.1  ];  // 数に対して，表示を行うかのフラグ[標示数値] [セグメント番号] const DIGIT_DISP_FLG: boolean[][] = [[ true, true, true, true, true, false, true], //0   [false, false, true, true, false, false, false], //1   [false, true, true, false, true, true, true], //2   [false, false, true, true, true, true, true], //3   [true, false, true, true, false, true, false], //4   [true, false, false, true, true, true, true], //5   [true, true, false, true, true, true, true], //6   [true, false, true, true, true, false, false], //7   [true, true, true, true, true, true, true], //8   [true, false, true, true, true, true, false ]];//9   p5obj.setup = () =>  {   // スクリーンサイズ(※手入力)   p5obj.createCanvas( 800, 450 );    let iDigitsCount: number = fDigitPos.length;  // 桁の数    // 各桁の座標と幅   let fDigitsWidth: number = p5obj.width * DIGITS_SCALE[0];   let fDigitWidth: number = fDigitsWidth / (iDigitsCount*(1+DIGIT_INTERVAL)+COLON_WIDTH_RATE);   let fDigitHeight: number = p5obj.height * DIGITS_SCALE[1];   let fDigitInterval: number = fDigitWidth * DIGIT_INTERVAL;   let fDigitPosX: number = ( p5obj.width - fDigitsWidth ) / 2.0;   for (let iDigitIdx: number = 0; iDigitIdx < fDigitPos.length; iDigitIdx++)   {     // コロンの場所を挿入.     if ( iDigitIdx == COLON_LOC_IDX)     {       fDigitPosX += fDigitWidth*COLON_WIDTH_RATE + fDigitInterval;     }     fDigitPos[iDigitIdx][0] = fDigitPosX;     fDigitPos[iDigitIdx][1] = ( p5obj.height - fDigitHeight ) / 2.0;     fDigitSize[iDigitIdx][0] = fDigitWidth;     fDigitSize[iDigitIdx][1] = fDigitHeight;     fDigitPosX += fDigitWidth + fDigitInterval;   }    // 縦長と横長のセグメントのサイズ[w,h]   let fSegmentSizeV: number[] = new Array(2).fill([]);   let fSegmentSizeH: number[] = new Array(2).fill([]);   fSegmentSizeV[0] = fSegmentsThickness[0] * fDigitWidth;   fSegmentSizeH[1] = fSegmentsThickness[1] * fDigitHeight;   fSegmentSizeV[1] = ( fDigitHeight - (1-fSegmentsLap)*(3 * fSegmentSizeH[1]) ) / 2.0;   fSegmentSizeH[0] = fDigitWidth - (1-fSegmentsLap)* (2 * fSegmentSizeV[0]);    // 各セグメントのローカル座標   let number fSegmentOfs[] = { ( fDigitWidth - fSegmentSizeH[0] )    / 2.0,     ( fDigitHeight - 2*fSegmentSizeV[1] ) / 3.0 };   fSegmentUpperLeft[0][0] = 0.0;   fSegmentUpperLeft[1][0] = 0.0;   fSegmentUpperLeft[2][0] = fDigitWidth - fSegmentSizeV[0];   fSegmentUpperLeft[3][0] = fSegmentUpperLeft[2][0];   fSegmentUpperLeft[4][0] = fSegmentOfs[0];   fSegmentUpperLeft[5][0] = fSegmentOfs[0];   fSegmentUpperLeft[6][0] = fSegmentOfs[0];   fSegmentUpperLeft[4][1] = 0;   fSegmentUpperLeft[0][1] = fSegmentOfs[1];   fSegmentUpperLeft[2][1] = fSegmentOfs[1];   fSegmentUpperLeft[5][1] = fDigitHeight / 2.0 - fSegmentSizeH[1] / 2.0;   {     let fOfsY: number = fSegmentSizeV[1] + 2 * fSegmentOfs[1];     fSegmentUpperLeft[1][1] = fOfsY;     fSegmentUpperLeft[3][1] = fOfsY;   }   fSegmentUpperLeft[6][1] = fDigitHeight - fSegmentSizeH[1];   for (let iSegmentIdx: number = 0; iSegmentIdx <= 3; iSegmentIdx++)   {     fSegmentSize[iSegmentIdx][0] = fSegmentSizeV[0];     fSegmentSize[iSegmentIdx][1] = fSegmentSizeV[1];   }   for (let iSegmentIdx: number = 4; iSegmentIdx < fSegmentUpperLeft.length; iSegmentIdx++)   {     fSegmentSize[iSegmentIdx][0] = fSegmentSizeH[0];     fSegmentSize[iSegmentIdx][1] = fSegmentSizeH[1];   }    p5obj.background(50, 50, 50);   p5obj.colorMode(p5obj.RGB, 256);   p5obj.frameRate(12); }  p5obj.draw = () =>  {   /*   // test:各桁のマスク表示    for(let iDigitIdx: number = 0; iDigitIdx < fDigitPos.length; iDigitIdx++)    {    p5obj.noStroke();    p5obj.fill(255,255,255);    p5obj.rect( fDigitPos[iDigitIdx][0],fDigitPos[iDigitIdx][1],    fDigitSize[iDigitIdx][0],fDigitSize[iDigitIdx][1]);    }    */   /*   // test:セグメントマスク表示    for(let iDigitIdx: number = 0; iDigitIdx < fDigitPos.length; iDigitIdx++)    {    p5obj.noStroke();    p5obj.fill(100,100,100);    for(let iSegmentIdx: number = 0; iSegmentIdx < fSegmentUpperLeft.length; iSegmentIdx++)    {    p5obj.rect( fSegmentUpperLeft[iSegmentIdx][0]+fDigitPos[iDigitIdx][0],    fSegmentUpperLeft[iSegmentIdx][1]+fDigitPos[iDigitIdx][1],    fSegmentSize[iSegmentIdx][0],    fSegmentSize[iSegmentIdx][1] );    }    }    */   /*   // test:現在時間マスク    let iHour: number = p5obj.hour() ;    let iMinute: number = p5obj.minute();    let iDispNumbers: number[] = [  iHour/10, iHour%10, iMinute/10, iMinute%10  ];    p5obj.noStroke();    for(let iDigitIdx: number = 0; iDigitIdx < fDigitPos.length; iDigitIdx++)    {    let iDispNumber: number = iDispNumbers[iDigitIdx];    for(let iSegmentIdx: number = 0; iSegmentIdx < fSegmentUpperLeft.length; iSegmentIdx++)    {    if( DIGIT_DISP_FLG[iDispNumber][iSegmentIdx] )    {    p5obj.fill(255,0,0);    p5obj.rect( fSegmentUpperLeft[iSegmentIdx][0]+fDigitPos[iDigitIdx][0],    fSegmentUpperLeft[iSegmentIdx][1]+fDigitPos[iDigitIdx][1],    fSegmentSize[iSegmentIdx][0],    fSegmentSize[iSegmentIdx][1] );    }    }    }    */    // 点描レンダリング   let iHour: number = p5obj.hour() ;   let iMinute: number = p5obj.minute();   let iDispNumbers: number[] = [  iHour/10, iHour%10, iMinute/10, iMinute%10  ];   p5obj.noStroke();   for (let iDigitIdx: number = 0; iDigitIdx < fDigitPos.length; iDigitIdx++)   {     let iDispNumber: number = iDispNumbers[iDigitIdx];     for (let iSegmentIdx: number = 0; iSegmentIdx < fSegmentUpperLeft.length; iSegmentIdx++)     {       if ( DIGIT_DISP_FLG[iDispNumber][iSegmentIdx] )       {         p5obj.fill(p5obj.random(255), p5obj.random(255), p5obj.random(255), 50);  // 点描       } else       {         p5obj.fill(50, 50, 50, 50);                          //　徐々にフェードアウト       }       p5obj.circle( fSegmentUpperLeft[iSegmentIdx][0]+fDigitPos[iDigitIdx][0] + p5obj.random(fSegmentSize[iSegmentIdx][0]),         fSegmentUpperLeft[iSegmentIdx][1]+fDigitPos[iDigitIdx][1] + p5obj.random(fSegmentSize[iSegmentIdx][1]),         6+p5obj.random(10))  ;     }   } }
};

export default sketch;
